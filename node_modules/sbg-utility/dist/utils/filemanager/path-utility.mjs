import fs from 'fs-extra';
import { platform } from 'os';
import path__default from 'path';
import path from 'upath';
import { promisify } from 'util';
import { fixDriveLetter } from './driveLetterUtils.mjs';

const readdir = promisify(fs.readdir);
const isWindows = platform() === 'win32';
const delimiter = isWindows ? '\\' : '/';
// --- SYNC true-case-path ---
function iterateSync(basePath, filePath, segments) {
  return segments.reduce((realPath, fileOrDirectory) => realPath + delimiter + matchCaseInsensitive(fileOrDirectory, fs.readdirSync(realPath + delimiter), filePath), basePath);
}
function trueCasePathSyncImpl(filePath, basePath) {
  if (!fs.existsSync(filePath)) return basePath ? path__default.join(basePath, filePath) : filePath;
  if (basePath) {
    if (!path__default.isAbsolute(basePath)) {
      throw new Error(`[true-case-path]: basePath argument must be absolute. Received "${basePath}"`);
    }
    basePath = path__default.normalize(basePath);
  }
  filePath = path__default.normalize(filePath);
  const segments = getRelevantFilePathSegments(filePath);
  if (path__default.isAbsolute(filePath)) {
    var _segments$shift;
    if (basePath) {
      throw new Error('[true-case-path]: filePath must be relative when used with basePath');
    }
    basePath = isWindows ? ((_segments$shift = segments.shift()) === null || _segments$shift === void 0 ? void 0 : _segments$shift.toUpperCase()) || '' : '';
  } else if (!basePath) {
    basePath = process.cwd();
  }
  return iterateSync(basePath, filePath, segments);
}
function trueCasePathSync(filePath, basePath, cbOpt) {
  if (filePath.length > 3) {
    var _callbackOpt;
    let bPath = undefined;
    let callbackOpt = Object.assign({
      unix: false
    }, cbOpt || {});
    if (typeof basePath === 'string') {
      bPath = basePath;
    } else if (typeof basePath === 'object') {
      callbackOpt = Object.assign({
        unix: false
      }, basePath || {});
    }
    let fPath = filePath;
    if (typeof bPath === 'string') fPath = path__default.join(bPath, filePath);
    fPath = path__default.normalize(fPath);
    let result;
    if (fs.existsSync(fPath)) {
      result = trueCasePathSyncImpl(filePath, bPath);
    } else {
      result = fPath.replace(/^([a-zA-Z]):/, (match, driveLetter) => driveLetter.toUpperCase() + ':');
    }
    return (_callbackOpt = callbackOpt) !== null && _callbackOpt !== void 0 && _callbackOpt.unix ? path.toUnix(result) : result;
  } else {
    if (typeof basePath === 'string') {
      return path__default.join(basePath, filePath);
    } else {
      return filePath;
    }
  }
}
// --- ASYNC true-case-path ---
async function iterateAsync(basePath, filePath, segments) {
  let realPath = basePath;
  for (const fileOrDirectory of segments) {
    realPath = realPath + delimiter + matchCaseInsensitive(fileOrDirectory, await readdir(realPath + delimiter), filePath);
  }
  return realPath;
}
async function trueCasePath(filePath, basePath, cbOpt) {
  if (filePath.length > 3) {
    var _callbackOpt2;
    let bPath = undefined;
    let callbackOpt = Object.assign({
      unix: false
    }, cbOpt || {});
    if (typeof basePath === 'string') {
      bPath = basePath;
    } else if (typeof basePath === 'object') {
      callbackOpt = Object.assign({
        unix: false
      }, basePath || {});
    }
    let fPath = filePath;
    if (typeof bPath === 'string') fPath = path__default.join(bPath, filePath);
    fPath = path__default.normalize(fPath);
    let result;
    if (fs.existsSync(fPath)) {
      // Async version
      result = await (async () => {
        let base = bPath;
        let fp = filePath;
        if (!fs.existsSync(fp)) return base ? path__default.join(base, fp) : fp;
        if (base) {
          if (!path__default.isAbsolute(base)) {
            throw new Error(`[true-case-path]: basePath argument must be absolute. Received "${base}"`);
          }
          base = path__default.normalize(base);
        }
        fp = path__default.normalize(fp);
        const segments = getRelevantFilePathSegments(fp);
        if (path__default.isAbsolute(fp)) {
          var _segments$shift2;
          if (base) {
            throw new Error('[true-case-path]: filePath must be relative when used with basePath');
          }
          base = isWindows ? ((_segments$shift2 = segments.shift()) === null || _segments$shift2 === void 0 ? void 0 : _segments$shift2.toUpperCase()) || '' : '';
        } else if (!base) {
          base = process.cwd();
        }
        return await iterateAsync(base, fp, segments);
      })();
    } else {
      result = fPath.replace(/^([a-zA-Z]):/, (match, driveLetter) => driveLetter.toUpperCase() + ':');
    }
    return (_callbackOpt2 = callbackOpt) !== null && _callbackOpt2 !== void 0 && _callbackOpt2.unix ? path.toUnix(result) : result;
  } else {
    if (typeof basePath === 'string') {
      return path__default.join(basePath, filePath);
    } else {
      return filePath;
    }
  }
}
/**
 * Normalizes a path and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Normalized path with correct case and drive letter
 */
/**
 * Normalizes a path and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Normalized path with correct case and drive letter
 */
function normalizePath(...str) {
  const join = path__default.join(...str);
  if (fs.existsSync(join)) {
    const casePath = trueCasePathSync(join);
    return fixDriveLetter(casePath);
  } else {
    return fixDriveLetter(join);
  }
}
/**
 * Normalizes a path to Unix style and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Unix style normalized path with correct case and drive letter
 */
/**
 * Normalizes a path to Unix style and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Unix style normalized path with correct case and drive letter
 */
function normalizePathUnix(...str) {
  const join = path.join(...str);
  if (fs.existsSync(join)) {
    const casePath = trueCasePathSync(join);
    return fixDriveLetter(path.toUnix(casePath));
  } else {
    return fixDriveLetter(join);
  }
}
/**
 * remove base path
 * @param target path to remove
 * @param toRemove cwd
 */
/**
 * Removes the base path from the target path.
 * @param target Path to remove from
 * @param toRemove Base path to remove
 */
function removeCwd(target, toRemove) {
  return normalizePath(target).replace(toRemove, '');
}
/**
 * UNIX join path with auto create dirname when not exists
 * @param path
 * @returns
 */
/**
 * Joins paths and creates the directory if it does not exist.
 * @param paths Path segments
 * @returns Joined path
 */
function joinSolve(...paths) {
  const merge = normalizePath(...paths);
  if (!fs.existsSync(path.dirname(merge))) {
    fs.mkdirSync(path.dirname(merge), {
      recursive: true
    });
  }
  return merge;
}
function getRelevantFilePathSegments(filePath) {
  return filePath.split(delimiter).filter(s => s !== '');
}
function escapeString(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function matchCaseInsensitive(fileOrDirectory, directoryContents, filePath) {
  const caseInsensitiveRegex = new RegExp(`^${escapeString(fileOrDirectory)}$`, 'i');
  for (const file of directoryContents) {
    if (caseInsensitiveRegex.test(file)) return file;
  }
  throw new Error(`[true-case-path]: Called with ${filePath}, but no matching file exists`);
}

export { isWindows, joinSolve, normalizePath, normalizePathUnix, removeCwd, trueCasePath, trueCasePathSync };
