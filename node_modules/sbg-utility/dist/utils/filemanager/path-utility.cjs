'use strict';

var fs = require('fs-extra');
var os = require('os');
var path = require('path');
var path$1 = require('upath');
var util = require('util');
var driveLetterUtils = require('./driveLetterUtils.cjs');

const readdir = util.promisify(fs.readdir);
const isWindows = os.platform() === 'win32';
const delimiter = isWindows ? '\\' : '/';
// --- SYNC true-case-path ---
function iterateSync(basePath, filePath, segments) {
  return segments.reduce((realPath, fileOrDirectory) => realPath + delimiter + matchCaseInsensitive(fileOrDirectory, fs.readdirSync(realPath + delimiter), filePath), basePath);
}
function trueCasePathSyncImpl(filePath, basePath) {
  if (!fs.existsSync(filePath)) return basePath ? path.join(basePath, filePath) : filePath;
  if (basePath) {
    if (!path.isAbsolute(basePath)) {
      throw new Error(`[true-case-path]: basePath argument must be absolute. Received "${basePath}"`);
    }
    basePath = path.normalize(basePath);
  }
  filePath = path.normalize(filePath);
  const segments = getRelevantFilePathSegments(filePath);
  if (path.isAbsolute(filePath)) {
    var _segments$shift;
    if (basePath) {
      throw new Error('[true-case-path]: filePath must be relative when used with basePath');
    }
    basePath = isWindows ? ((_segments$shift = segments.shift()) === null || _segments$shift === void 0 ? void 0 : _segments$shift.toUpperCase()) || '' : '';
  } else if (!basePath) {
    basePath = process.cwd();
  }
  return iterateSync(basePath, filePath, segments);
}
function trueCasePathSync(filePath, basePath, cbOpt) {
  if (filePath.length > 3) {
    var _callbackOpt;
    let bPath = undefined;
    let callbackOpt = Object.assign({
      unix: false
    }, cbOpt || {});
    if (typeof basePath === 'string') {
      bPath = basePath;
    } else if (typeof basePath === 'object') {
      callbackOpt = Object.assign({
        unix: false
      }, basePath || {});
    }
    let fPath = filePath;
    if (typeof bPath === 'string') fPath = path.join(bPath, filePath);
    fPath = path.normalize(fPath);
    let result;
    if (fs.existsSync(fPath)) {
      result = trueCasePathSyncImpl(filePath, bPath);
    } else {
      result = fPath.replace(/^([a-zA-Z]):/, (match, driveLetter) => driveLetter.toUpperCase() + ':');
    }
    return (_callbackOpt = callbackOpt) !== null && _callbackOpt !== void 0 && _callbackOpt.unix ? path$1.toUnix(result) : result;
  } else {
    if (typeof basePath === 'string') {
      return path.join(basePath, filePath);
    } else {
      return filePath;
    }
  }
}
// --- ASYNC true-case-path ---
async function iterateAsync(basePath, filePath, segments) {
  let realPath = basePath;
  for (const fileOrDirectory of segments) {
    realPath = realPath + delimiter + matchCaseInsensitive(fileOrDirectory, await readdir(realPath + delimiter), filePath);
  }
  return realPath;
}
async function trueCasePath(filePath, basePath, cbOpt) {
  if (filePath.length > 3) {
    var _callbackOpt2;
    let bPath = undefined;
    let callbackOpt = Object.assign({
      unix: false
    }, cbOpt || {});
    if (typeof basePath === 'string') {
      bPath = basePath;
    } else if (typeof basePath === 'object') {
      callbackOpt = Object.assign({
        unix: false
      }, basePath || {});
    }
    let fPath = filePath;
    if (typeof bPath === 'string') fPath = path.join(bPath, filePath);
    fPath = path.normalize(fPath);
    let result;
    if (fs.existsSync(fPath)) {
      // Async version
      result = await (async () => {
        let base = bPath;
        let fp = filePath;
        if (!fs.existsSync(fp)) return base ? path.join(base, fp) : fp;
        if (base) {
          if (!path.isAbsolute(base)) {
            throw new Error(`[true-case-path]: basePath argument must be absolute. Received "${base}"`);
          }
          base = path.normalize(base);
        }
        fp = path.normalize(fp);
        const segments = getRelevantFilePathSegments(fp);
        if (path.isAbsolute(fp)) {
          var _segments$shift2;
          if (base) {
            throw new Error('[true-case-path]: filePath must be relative when used with basePath');
          }
          base = isWindows ? ((_segments$shift2 = segments.shift()) === null || _segments$shift2 === void 0 ? void 0 : _segments$shift2.toUpperCase()) || '' : '';
        } else if (!base) {
          base = process.cwd();
        }
        return await iterateAsync(base, fp, segments);
      })();
    } else {
      result = fPath.replace(/^([a-zA-Z]):/, (match, driveLetter) => driveLetter.toUpperCase() + ':');
    }
    return (_callbackOpt2 = callbackOpt) !== null && _callbackOpt2 !== void 0 && _callbackOpt2.unix ? path$1.toUnix(result) : result;
  } else {
    if (typeof basePath === 'string') {
      return path.join(basePath, filePath);
    } else {
      return filePath;
    }
  }
}
/**
 * Normalizes a path and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Normalized path with correct case and drive letter
 */
/**
 * Normalizes a path and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Normalized path with correct case and drive letter
 */
function normalizePath(...str) {
  const join = path.join(...str);
  if (fs.existsSync(join)) {
    const casePath = trueCasePathSync(join);
    return driveLetterUtils.fixDriveLetter(casePath);
  } else {
    return driveLetterUtils.fixDriveLetter(join);
  }
}
/**
 * Normalizes a path to Unix style and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Unix style normalized path with correct case and drive letter
 */
/**
 * Normalizes a path to Unix style and applies true-case-path if the file exists.
 * @param str Path segments
 * @returns Unix style normalized path with correct case and drive letter
 */
function normalizePathUnix(...str) {
  const join = path$1.join(...str);
  if (fs.existsSync(join)) {
    const casePath = trueCasePathSync(join);
    return driveLetterUtils.fixDriveLetter(path$1.toUnix(casePath));
  } else {
    return driveLetterUtils.fixDriveLetter(join);
  }
}
/**
 * remove base path
 * @param target path to remove
 * @param toRemove cwd
 */
/**
 * Removes the base path from the target path.
 * @param target Path to remove from
 * @param toRemove Base path to remove
 */
function removeCwd(target, toRemove) {
  return normalizePath(target).replace(toRemove, '');
}
/**
 * UNIX join path with auto create dirname when not exists
 * @param path
 * @returns
 */
/**
 * Joins paths and creates the directory if it does not exist.
 * @param paths Path segments
 * @returns Joined path
 */
function joinSolve(...paths) {
  const merge = normalizePath(...paths);
  if (!fs.existsSync(path$1.dirname(merge))) {
    fs.mkdirSync(path$1.dirname(merge), {
      recursive: true
    });
  }
  return merge;
}
function getRelevantFilePathSegments(filePath) {
  return filePath.split(delimiter).filter(s => s !== '');
}
function escapeString(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function matchCaseInsensitive(fileOrDirectory, directoryContents, filePath) {
  const caseInsensitiveRegex = new RegExp(`^${escapeString(fileOrDirectory)}$`, 'i');
  for (const file of directoryContents) {
    if (caseInsensitiveRegex.test(file)) return file;
  }
  throw new Error(`[true-case-path]: Called with ${filePath}, but no matching file exists`);
}

exports.isWindows = isWindows;
exports.joinSolve = joinSolve;
exports.normalizePath = normalizePath;
exports.normalizePathUnix = normalizePathUnix;
exports.removeCwd = removeCwd;
exports.trueCasePath = trueCasePath;
exports.trueCasePathSync = trueCasePathSync;
