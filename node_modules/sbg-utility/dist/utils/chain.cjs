'use strict';

var ansiColors = require('ansi-colors');
var index = require('../dependencies/is-stream/index.cjs');
var logger = require('./logger.cjs');

/**
 * Chainable function runner.
 *
 * @param schedule - An array of function objects, each containing a callback and optional `opt` properties for before and after functions.
 * @example
 * ```ts
 * chain([
 *   {
 *     callback: () => 'stream process eg: gulp',
 *     opt: {
 *       before: () => 'run before callback called',
 *       after: () => 'run after callback called'
 *     }
 *   },
 *   {
 *     callback: () => 'promise process'
 *   },
 *   {
 *     callback: () => 'synchronous function'
 *   }
 * ]);
 * ```
 */
async function chain(schedule) {
  // NodeJS.ReadWriteStream | Promise<any>
  const run = function (instance) {
    return new Promise(resolve => {
      var _instance$opt;
      const logname = ansiColors.blueBright('chain') + '.' + ansiColors.yellowBright('run');
      if ((_instance$opt = instance.opt) !== null && _instance$opt !== void 0 && _instance$opt.before) {
        instance.opt.before();
      }
      const obj = instance.callback.call && instance.callback.call(null);
      // Logger.log(
      //   `is readable stream ${isReadableStream(obj)}`,
      //   `is writable stream ${isWritableStream(obj)}`,
      //   `is promise ${isPromise(obj)}`,
      //   `is stream ${isStream(obj)}`,
      //   { keys: Object.keys(obj) }
      // );
      if (index.isReadableStream(obj)) {
        logger.Logger.log('readable stream');
        return obj.once('end', async () => {
          var _instance$opt2;
          if ((_instance$opt2 = instance.opt) !== null && _instance$opt2 !== void 0 && _instance$opt2.after) {
            await instance.opt.after();
            return resolve(this);
          } else {
            return resolve(this);
          }
        });
      } else if (index.isWritableStream(obj)) {
        logger.Logger.log('writable stream');
        return obj.once('finish', async () => {
          var _instance$opt3;
          if ((_instance$opt3 = instance.opt) !== null && _instance$opt3 !== void 0 && _instance$opt3.after) {
            await instance.opt.after();
            return resolve(this);
          } else {
            return resolve(this);
          }
        });
      } else if (index.isStream(obj)) {
        // gulp instance / readwrite stream
        return obj.once('end', async () => {
          var _instance$opt4;
          if ((_instance$opt4 = instance.opt) !== null && _instance$opt4 !== void 0 && _instance$opt4.after) {
            await instance.opt.after();
            return resolve(this);
          } else {
            return resolve(this);
          }
        });
      } else if (isPromise(obj)) {
        //Logger.log('promises');
        return obj.then(async () => {
          var _instance$opt5;
          if ((_instance$opt5 = instance.opt) !== null && _instance$opt5 !== void 0 && _instance$opt5.after) {
            await instance.opt.after();
            return resolve(this);
          } else {
            return resolve(this);
          }
        });
      } else {
        if (typeof instance.callback !== 'function') {
          logger.Logger.log(logname, 'cannot determine method instances');
        }
      }
      resolve.bind(this)(chain.bind(this));
    });
  };
  while (schedule.length > 0) {
    const instance = schedule.shift();
    if (typeof instance !== 'undefined') await run(instance);
  }
}
/**
 * check object is Promises
 * @param p
 * @returns
 */
function isPromise(p) {
  return p && String(Object.prototype.toString.call(p)).toLowerCase() === '[object promise]' ||
  // check ES6 Promises
  p && typeof p.constructor === 'function' && Function.prototype.toString.call(p.constructor).replace(/\(.*\)/, '()') === Function.prototype.toString.call(/*native object*/Function).replace('Function', 'Promise') // replacing Identifier
  .replace(/\(.*\)/, '()') ||
  // removing possible FormalParameterList
  // my own experiment
  p && String(Function.prototype.toString.call(p.constructor)).startsWith('function Promise(');
}

exports.chain = chain;
