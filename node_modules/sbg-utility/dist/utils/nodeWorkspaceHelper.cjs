'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var micromatch = require('micromatch');
var path = require('path');
var url = require('url');
var logger = require('./logger.cjs');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const __filename$1 = url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils/nodeWorkspaceHelper.cjs', document.baseURI).href)));
const __dirname$1 = path.dirname(__filename$1);
/**
 * search yarn root workspace folder
 * @param ctx option with property `base_dir`
 */
function findYarnRootWorkspace(ctx) {
  const baseDir = ctx.base_dir;
  /**
   * extract workspaces from package.json
   * @param manifest
   * @returns
   */
  const extractWorkspaces = function (manifest) {
    const workspaces = (manifest || {}).workspaces;
    return workspaces && workspaces.packages || (Array.isArray(workspaces) ? workspaces : null);
  };
  /**
   * read package.json from given folder
   * @param dir
   * @returns
   */
  const readPackageJSON = function (dir) {
    const file = path.join(dir, 'package.json');
    if (fs.existsSync(file)) {
      return JSON.parse(fs.readFileSync(file).toString());
    }
  };
  let previous = 'THIS INITIATOR VALUE WILL NEVER EXECUTED';
  let current = path.normalize(baseDir);
  // loop searching
  do {
    const manifest = readPackageJSON(current);
    if (!manifest) continue;
    const workspaces = extractWorkspaces(manifest);
    if (workspaces) {
      const relativePath = path.relative(current, baseDir);
      if (relativePath === '' || micromatch([relativePath], workspaces).length > 0) {
        return current;
      }
      return null;
    }
    previous = current;
    current = path.dirname(current);
  } while (current !== previous);
  return null;
}
/**
 * Resolves the path of a command binary from `node_modules/.bin`.
 *
 * This function searches for the specified command in various directories, including
 * the current working directory, the module directory, and optionally, user-defined
 * search directories. If the command is not found, it returns the original command name.
 *
 * @param commandName - The name of the command to resolve.
 * @param options - Optional parameters for command resolution.
 * @param options.searchDir - A custom directory or an array of directories to search for
 *   the command. If provided, these directories will be included in the search.
 * @returns The resolved command path if found; otherwise, returns the original command name.
 */
function resolveCommand(commandName, options) {
  const dirs = [__dirname$1, process.cwd()];
  if (typeof process === 'object') {
    var _process$mainModule, _process$main;
    if ('mainModule' in process) dirs.push((_process$mainModule = process.mainModule) === null || _process$mainModule === void 0 ? void 0 : _process$mainModule.paths[0].split('node_modules')[0].slice(0, -1));
    if ('main' in process) dirs.push((_process$main = process.main) === null || _process$main === void 0 ? void 0 : _process$main.paths[0].split('node_modules')[0].slice(0, -1));
  }
  if (options && options.searchDir) {
    if (!Array.isArray(options.searchDir)) {
      options.searchDir = [options.searchDir];
    }
    dirs.push(...options.searchDir);
  }
  // try {
  //   dirs.push(findYarnRootWorkspace({ base_dir: process.cwd() }));
  // } catch (_) {
  //   //
  // }
  const cmdPath = dirs.filter(str => typeof str === 'string' && str.length > 0).map(cwd => {
    const nm = path.join(cwd, 'node_modules/.bin');
    return path.join(nm, commandName);
  }).filter(fs.existsSync)[0];
  if (!cmdPath) {
    logger.Logger.error(`Command '${commandName}' not found in node_modules/.bin`);
    return commandName; // Return the original command name
  }
  return process.platform === 'win32' ? `${cmdPath}.cmd` : cmdPath;
}
const cmd = resolveCommand;

exports.cmd = cmd;
exports.default = findYarnRootWorkspace;
exports.findYarnRootWorkspace = findYarnRootWorkspace;
exports.resolveCommand = resolveCommand;
