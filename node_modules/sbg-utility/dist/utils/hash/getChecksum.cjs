'use strict';

var CryptoJS = require('crypto-js');
var fs = require('fs-extra');
var glob = require('glob');
var path = require('upath');
var url = require('url');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var glob__namespace = /*#__PURE__*/_interopNamespaceDefault(glob);

const __filename$1 = url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils/hash/getChecksum.cjs', document.baseURI).href)));
path.dirname(__filename$1);
/**
 * Calculate a checksum for the given target paths.
 * This checksum is used to determine if the source files have changed
 * and whether a build is necessary.
 *
 * @param targetPaths - An array of file or directory paths to include in the checksum.
 * @returns A SHA-256 hash of the contents of the specified files and directories.
 */
function getChecksum(...targetPaths) {
  const files = [];
  for (const pattern of targetPaths) {
    if (fs.existsSync(pattern)) {
      const stat = fs.statSync(pattern);
      if (stat.isFile()) {
        files.push(path.resolve(pattern));
      } else if (stat.isDirectory()) {
        const dirFiles = glob__namespace.sync('**/*', {
          cwd: pattern,
          nodir: true,
          absolute: true,
          dot: true
        });
        files.push(...dirFiles);
      }
    } else {
      const matches = glob__namespace.sync(pattern, {
        nodir: true,
        absolute: true,
        dot: true
      });
      files.push(...matches);
    }
  }
  const uniqueFiles = Array.from(new Set(files)).sort();
  const hash = CryptoJS.algo.SHA256.create();
  for (const file of uniqueFiles) {
    const fileBuffer = fs.readFileSync(file);
    const chunkSize = 1024 * 1024; // 1MB
    for (let offset = 0; offset < fileBuffer.length; offset += chunkSize) {
      const chunk = fileBuffer.subarray(offset, Math.min(offset + chunkSize, fileBuffer.length));
      hash.update(CryptoJS.lib.WordArray.create(chunk));
    }
  }
  return hash.finalize().toString(CryptoJS.enc.Hex);
}

module.exports = getChecksum;
