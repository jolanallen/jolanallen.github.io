import async from 'async';
import Bluebird from 'bluebird';
import { parse } from 'node-html-parser';
import ProgressBar from 'progress';
import request from 'request';
import 'ansi-colors';
import { Logger } from '../utils/logger.mjs';
import { debug } from '../utils/debug.mjs';
import '../utils/decode-url.mjs';
import '../utils/deepMerge.mjs';
import '../utils/encode-url.mjs';
import 'fs-extra';
import 'upath';
import 'path';
import 'minimatch';
import '../utils/filemanager/getAppRootDir.mjs';
import '../utils/filemanager/path-utility.mjs';
import '../utils/generate-exports.mjs';
import '../utils/hash.mjs';
import '../utils/hash/getChecksum.mjs';
import '../utils/JSON.mjs';
import '../utils/JSON-serializer.mjs';
import '../utils/LocalStorageSharedPreferences.mjs';
import 'os';
import '../utils/scheduler.mjs';
import '../utils/nodeWorkspaceHelper.mjs';
import 'nunjucks';
import '../utils/promisify.mjs';
import '../utils/_punycode.mjs';
import 'fs';
import 'stream';

class SiteMapCrawlerCore {
  static start(links, core_opt, isCounting, callback) {
    const {
      isProgress,
      isLog
    } = core_opt;
    const siteMap = {};
    let bar;
    if (isProgress) {
      bar = new ProgressBar('siteMap-crawling [:bar] :percent', {
        total: links.length
      });
    }
    async.each(links, (link, callback) => {
      const done = () => {
        if (isProgress) {
          bar.tick();
        }
        callback();
      };
      const self = this;
      request(link, (err, res, body) => {
        if (err) {
          if (isLog) {
            const {
              errno,
              code,
              syscall,
              host
            } = err;
            Logger.log(`\nError: ${errno} ${code} ${syscall}, ${host}`);
          }
          return done();
        }
        try {
          const root = parse(body);
          const hrefElements = root.querySelectorAll('[href]');
          const filteredLinks = new Set();
          hrefElements.forEach(element => {
            var _self$filterLink;
            if (element.tagName.toLowerCase() !== 'a') {
              const href = element.getAttribute('href');
              if (!href || !/(\/|.html)$/gi.test(href)) return;
            }
            const hrefAttr = element.getAttribute('href') || '';
            const href = (_self$filterLink = self.filterLink(link, hrefAttr)) === null || _self$filterLink === void 0 ? void 0 : _self$filterLink.trim();
            if (typeof href === 'string' && href.length > 0) {
              const dirUrl = link.substring(0, link.lastIndexOf('/'));
              if (/^https?:\/\//i.test(href.trim())) {
                filteredLinks.add(href);
              } else {
                filteredLinks.add(dirUrl + '/' + href);
              }
            }
          });
          const arrayLinks = Array.from(filteredLinks).map(url => {
            if (url.endsWith('/')) {
              // url ends with. / -> /index.html
              url += 'index.html';
            } else if (!/(\w+\.\w+)$/.test(url)) {
              // url doesnt have extension. /path -> /path/index.html
              url += '/index.html';
            }
            if (!core_opt.keepQuery) return url.split('?')[0];
            return url;
          });
          if (arrayLinks.length > 0) {
            siteMap[link] = arrayLinks;
          }
        } catch {
          Logger.log('sitemap-crawler', 'cannot parse', link);
        }
        return done();
      });
    }, err => {
      if (err) {
        return callback(err);
      }
      const count = Object.keys(siteMap).length;
      const siteMapObj = isCounting ? {
        count,
        siteMap
      } : siteMap[links];
      callback(null, siteMapObj);
    });
  }
  static filterLink(parent, href) {
    const ignores = ['^javascript', 'css', 'ico', '#', '^/$', '^#none$', '^$', '@', 'png', 'svg', 'manifest.json', 'pdf$', '^tel', '^sms', '^mailto', 'admin', 'login', 'register'];
    const rIgnores = new RegExp(ignores.join('|'), 'i');
    if (isValidHttpUrl(href)) {
      const parentHostName = new URL(parent).hostname;
      const hrefHostName = new URL(href).hostname;
      if (parentHostName === hrefHostName && !href.match(rIgnores)) {
        return href;
      }
    }
    if (!href.match(rIgnores) && !href.includes('//')) {
      const base = new URL(parent);
      const resolvedUrl = fixUrl([String(new URL(base.origin + '/' + href))])[0];
      //console.log(parent, href, resolvedUrl);
      return resolvedUrl;
    }
    return null;
  }
}
/**
 * add protocol
 * @param link
 * @returns empty string when invalid link
 */
function attachProtocol(link) {
  if (link.startsWith('/')) {
    debug('sitemap-crawler')('start with slash', link);
    return '';
  } else if (link.startsWith('#')) {
    debug('sitemap-crawler')('start with hash', link);
    return '';
  }
  if (!/^https?:/i.test(link)) {
    return 'http://' + link;
  }
  return link;
}
const sitemapCrawler = (link, opts, callback) => {
  let isProgress = false,
    isLog = false,
    isCounting = true;
  opts = Object.assign({
    isProgress: false,
    isLog: false
  }, opts || {});
  if (typeof opts === 'function') {
    callback = opts;
  } else {
    isProgress = opts.isProgress || false;
    isLog = opts.isLog || false;
  }
  if (typeof link === 'string') {
    link = attachProtocol(link);
    link = [link];
    isCounting = false;
  } else {
    link = link.map(l => {
      return attachProtocol(l);
    });
  }
  SiteMapCrawlerCore.start(link, {
    isProgress,
    isLog
  }, isCounting, callback || noop);
};
const asyncResults = {};
/**
 * Sitemap Crawler Asynchronous
 * @param link
 * @param opts
 * @returns
 */
function sitemapCrawlerAsync(link, opts) {
  return new Bluebird(resolve => {
    // assign with default option
    opts = Object.assign({
      deep: 0,
      isLog: false,
      keepQuery: false,
      isProgress: false
    }, opts || {});
    // crawler
    const crawl = url => {
      return new Bluebird(resolveCrawl => {
        sitemapCrawler(url, opts, function (e, links) {
          if (!e) {
            const key = new URL(url).origin;
            // append to asyncResult
            asyncResults[key] = fixUrl(links || []).concat(asyncResults[key] || []);
          } else {
            Logger.log('err', e);
          }
          resolveCrawl(asyncResults);
        });
      });
    };
    let linkArr = [];
    const crawled = [];
    const schedule = () => {
      return new Bluebird(resolveSchedule => {
        const url = linkArr.shift();
        if (crawled.includes(url)) return resolveSchedule();
        crawled.push(url);
        crawl(url).then(() => {
          if (linkArr.length > 0) {
            schedule().then(resolveSchedule);
          } else {
            resolveSchedule();
          }
        });
      });
    };
    if (typeof link === 'string') {
      linkArr.push(link);
    } else {
      linkArr = link;
    }
    const deepIterate = () => {
      return new Promise(resolveLoop => {
        schedule().then(() => {
          var _opts;
          if (typeof ((_opts = opts) === null || _opts === void 0 ? void 0 : _opts.deep) === 'number') {
            if (opts.deep > 0) {
              opts.deep = opts.deep - 1;
              linkArr = Object.values(asyncResults).flat(1);
              deepIterate().then(resolveLoop);
            } else {
              resolveLoop(null);
            }
          } else {
            resolveLoop(null);
          }
        });
      });
    };
    deepIterate().then(() => {
      Object.keys(asyncResults).forEach(key => {
        asyncResults[key] = fixUrl(asyncResults[key]);
      });
      resolve(asyncResults);
    });
  });
}
function noop() {
  //
}
function isValidHttpUrl(string) {
  let url;
  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }
  return url.protocol === 'http:' || url.protocol === 'https:';
}
function fixUrl(links) {
  return links.map(url => {
    //const parse = new URL(url);
    //url = parse.toString();
    // remove double slash from pathname
    url = url.replace(/(https?:\/\/)|(\/)+/gim, '$1$2');
    return url;
  })
  // remove duplicated urls
  .filter(function (x, i, a) {
    return a.indexOf(x) === i;
  })
  // sort alphabetically
  .sort(function (a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  });
}

export { SiteMapCrawlerCore, sitemapCrawler as default, sitemapCrawler, sitemapCrawlerAsync };
