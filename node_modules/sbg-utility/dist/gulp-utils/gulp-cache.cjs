'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var crypto = require('crypto');
var fs = require('fs-extra');
var os = require('os');
var through2 = require('through2');
var path = require('upath');
var _config = require('../config/_config.cjs');
require('ansi-colors');
require('../utils/logger.cjs');
require('debug');
require('../utils/decode-url.cjs');
require('../utils/deepMerge.cjs');
require('../utils/encode-url.cjs');
require('path');
require('bluebird');
require('minimatch');
require('../utils/filemanager/getAppRootDir.cjs');
var pathUtility = require('../utils/filemanager/path-utility.cjs');
var writefile = require('../utils/filemanager/writefile.cjs');
require('../utils/generate-exports.cjs');
var hash = require('../utils/hash.cjs');
require('../utils/hash/getChecksum.cjs');
require('../utils/JSON.cjs');
require('../utils/JSON-serializer.cjs');
require('../utils/LocalStorageSharedPreferences.cjs');
require('../utils/scheduler.cjs');
require('../utils/nodeWorkspaceHelper.cjs');
require('nunjucks');
var persistentCache = require('../utils/persistent-cache.cjs');
require('../utils/promisify.cjs');
require('../utils/_punycode.cjs');
require('fs');
require('stream');

/**
 * calculate sha1sum of file
 * @param file
 * @returns
 */
function getShaFile(file) {
  if (fs.statSync(file).isDirectory()) return null;
  const testFile = fs.readFileSync(file);
  const sha1sum = crypto.createHash('sha1').update(testFile).digest('hex');
  return sha1sum;
}
function cacheLib(options) {
  const config = _config.getConfig();
  options = Object.assign({
    name: 'gulp-cached',
    base: path.join(config.cwd, 'tmp'),
    prefix: ''
  }, options);
  return new persistentCache.persistentCache(options);
}
/**
 * * [source idea](https://github.com/gulp-community/gulp-cached/blob/8e8d13cb07b17113ff94700e87f136eeaa1f1340/index.js#L35-L44)
 * @param options
 * @returns
 */
function gulpCached(options = {}) {
  const caches = cacheLib(options);
  //const logname = 'gulp-' + ansiColors.grey('cached');
  const pid = process.pid;
  let caller;
  if (options.name) {
    caller = options.name;
  } else {
    var _Error$stack;
    caller = hash.data_to_hash_sync('md5', ((_Error$stack = new Error('get caller').stack) === null || _Error$stack === void 0 ? void 0 : _Error$stack.split(/\r?\n/gim).filter(str => /(dist|src)/i.test(str))[1]) || '').slice(0, 5) + '-' + pid;
  }
  return through2.obj(function (file, _enc, next) {
    var _options$dest, _options$cwd;
    // skip directory
    if (file.isDirectory()) return next(null, file);
    const cacheKey = hash.md5(file.path);
    const sha1sum = getShaFile(file.path);
    /**
     * Checks if file has been changed by comparing its current SHA1
     * hash with the one in cache, if present. Returns true if the
     * file hasChanged, false if not.
     */
    const isChanged = () => {
      const currentHash = caches.getSync(cacheKey, '');
      const newHash = getShaFile(file.path);
      // If no hash exists for file, consider file has changed
      // cache has expired or cache file has been deleted
      if (!currentHash) {
        return true;
      }
      // Cache exists and hashes differ
      if (currentHash && currentHash !== newHash) {
        return true;
      }
      // check destination when cache exist
      if (options.dest && options.cwd) {
        const destPath = path.join(pathUtility.normalizePath(options.dest), pathUtility.removeCwd(file.path, options.cwd));
        return fs.existsSync(destPath);
      }
      // File has not changed, leave cache as-
      return false;
    };
    const paths = {
      dest: pathUtility.normalizePath(((_options$dest = options.dest) === null || _options$dest === void 0 ? void 0 : _options$dest.replace(process.cwd(), '')) || ''),
      cwd: pathUtility.normalizePath(((_options$cwd = options.cwd) === null || _options$cwd === void 0 ? void 0 : _options$cwd.replace(process.cwd(), '')) || ''),
      source: pathUtility.normalizePath(file.path.replace(process.cwd(), ''))
    };
    // dump
    const dumpfile = path.join(process.cwd(), 'tmp/dump/gulp-cached', `${caller}.log`);
    writefile.writefile(dumpfile, `"${paths.source}" is cached ${isChanged()} with dest validation ${options.dest && options.cwd ? 'true' : 'false'}` + os.EOL, {
      append: true
    });
    /*scheduler.add(`${logname} dump ${ansiColors.cyan(caller)} pid ${ansiColors.yellow(String(pid))}`, () =>
      console.log(logname, dumpfile)
    );*/
    if (isChanged()) {
      // not cached
      caches.setSync(cacheKey, sha1sum);
      // push modified file
      if (typeof this.push === 'function') this.push(file);
      return next();
    } else {
      // cached
      // drop non-modified data
      return next();
    }
  });
}

exports.default = gulpCached;
exports.getShaFile = getShaFile;
exports.gulpCached = gulpCached;
